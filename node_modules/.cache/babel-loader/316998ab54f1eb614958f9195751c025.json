{"ast":null,"code":"import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n}\n\nvar ALIGNMENT;\n\n(function (ALIGNMENT) {\n  ALIGNMENT[\"AUTO\"] = \"auto\";\n  ALIGNMENT[\"START\"] = \"start\";\n  ALIGNMENT[\"CENTER\"] = \"center\";\n  ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\n\nvar DIRECTION;\n\n(function (DIRECTION) {\n  DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n  DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\n\nvar SCROLL_CHANGE_REASON;\n\n(function (SCROLL_CHANGE_REASON) {\n  SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n  SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\n\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\n\nvar _a;\n\nvar _b;\n\nvar _c;\n\nvar _d;\n\nvar _e;\n/* Forked from react-virtualized ðŸ’– */\n\n\nvar SizeAndPositionManager =\n/** @class */\nfunction () {\n  function SizeAndPositionManager(_a) {\n    var itemCount = _a.itemCount,\n        itemSizeGetter = _a.itemSizeGetter,\n        estimatedItemSize = _a.estimatedItemSize;\n    this.itemSizeGetter = itemSizeGetter;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize; // Cache of size and position data for items, mapped by item index.\n\n    this.itemSizeAndPositionData = {}; // Measurements for items up to this index can be trusted; items afterward should be estimated.\n\n    this.lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.updateConfig = function (_a) {\n    var itemCount = _a.itemCount,\n        itemSizeGetter = _a.itemSizeGetter,\n        estimatedItemSize = _a.estimatedItemSize;\n\n    if (itemCount != null) {\n      this.itemCount = itemCount;\n    }\n\n    if (estimatedItemSize != null) {\n      this.estimatedItemSize = estimatedItemSize;\n    }\n\n    if (itemSizeGetter != null) {\n      this.itemSizeGetter = itemSizeGetter;\n    }\n  };\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n    return this.lastMeasuredIndex;\n  };\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n    if (index < 0 || index >= this.itemCount) {\n      throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n    }\n\n    if (index > this.lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this.itemSizeGetter(i);\n\n        if (size == null || isNaN(size)) {\n          throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n        }\n\n        this.itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n        offset += size;\n      }\n\n      this.lastMeasuredIndex = index;\n    }\n\n    return this.itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n    return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : {\n      offset: 0,\n      size: 0\n    };\n  };\n  /**\n   * Total size of all items being measured.\n   * This value will be completedly estimated initially.\n   * As items as measured the estimate will be updated.\n   */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function () {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n  };\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n    var _b = _a.align,\n        align = _b === void 0 ? ALIGNMENT.START : _b,\n        containerSize = _a.containerSize,\n        currentOffset = _a.currentOffset,\n        targetIndex = _a.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n    var idealOffset;\n\n    switch (align) {\n      case ALIGNMENT.END:\n        idealOffset = minOffset;\n        break;\n\n      case ALIGNMENT.CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n\n      case ALIGNMENT.START:\n        idealOffset = maxOffset;\n        break;\n\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n    }\n\n    var totalSize = this.getTotalSize();\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n    var containerSize = _a.containerSize,\n        offset = _a.offset,\n        overscanCount = _a.overscanCount;\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this.findNearestItem(offset);\n\n    if (typeof start === 'undefined') {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    }\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n    var stop = start;\n\n    while (offset < maxOffset && stop < this.itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function (index) {\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n  };\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n    if (isNaN(offset)) {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    } // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n\n\n    offset = Math.max(0, offset);\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this.binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this.exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  SizeAndPositionManager.prototype.binarySearch = function (_a) {\n    var low = _a.low,\n        high = _a.high,\n        offset = _a.offset;\n    var middle = 0;\n    var currentOffset = 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n\n    return 0;\n  };\n\n  SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n    var index = _a.index,\n        offset = _a.offset;\n    var interval = 1;\n\n    while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this.binarySearch({\n      high: Math.min(index, this.itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  return SizeAndPositionManager;\n}();\n\nvar STYLE_WRAPPER = {\n  overflow: 'auto',\n  willChange: 'transform',\n  WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n  position: 'relative',\n  width: '100%',\n  minHeight: '100%'\n};\nvar STYLE_ITEM = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%'\n};\n\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, {\n  position: 'sticky'\n});\n\nvar VirtualList =\n/** @class */\nfunction (_super) {\n  __extends(VirtualList, _super);\n\n  function VirtualList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.itemSizeGetter = function (itemSize) {\n      return function (index) {\n        return _this.getSize(index, itemSize);\n      };\n    };\n\n    _this.sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n      estimatedItemSize: _this.getEstimatedItemSize()\n    });\n    _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n      scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n    };\n    _this.styleCache = {};\n\n    _this.getRef = function (node) {\n      _this.rootNode = node;\n    };\n\n    _this.handleScroll = function (event) {\n      var onScroll = _this.props.onScroll;\n\n      var offset = _this.getNodeOffset();\n\n      if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n        return;\n      }\n\n      _this.setState({\n        offset: offset,\n        scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n      });\n\n      if (typeof onScroll === 'function') {\n        onScroll(offset, event);\n      }\n    };\n\n    return _this;\n  }\n\n  VirtualList.prototype.componentDidMount = function () {\n    var _a = this.props,\n        scrollOffset = _a.scrollOffset,\n        scrollToIndex = _a.scrollToIndex;\n    this.rootNode.addEventListener('scroll', this.handleScroll, {\n      passive: true\n    });\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n\n  VirtualList.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var _a = this.props,\n        estimatedItemSize = _a.estimatedItemSize,\n        itemCount = _a.itemCount,\n        itemSize = _a.itemSize,\n        scrollOffset = _a.scrollOffset,\n        scrollToAlignment = _a.scrollToAlignment,\n        scrollToIndex = _a.scrollToIndex;\n    var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n    var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n\n    if (nextProps.itemSize !== itemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n      });\n    }\n\n    if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\n      });\n    }\n\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset || 0,\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n      });\n    } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n      });\n    }\n  };\n\n  VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n    var _a = this.state,\n        offset = _a.offset,\n        scrollChangeReason = _a.scrollChangeReason;\n\n    if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n      this.scrollTo(offset);\n    }\n  };\n\n  VirtualList.prototype.componentWillUnmount = function () {\n    this.rootNode.removeEventListener('scroll', this.handleScroll);\n  };\n\n  VirtualList.prototype.scrollTo = function (value) {\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    this.rootNode[scrollProp[scrollDirection]] = value;\n  };\n\n  VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n    if (scrollToAlignment === void 0) {\n      scrollToAlignment = this.props.scrollToAlignment;\n    }\n\n    if (itemCount === void 0) {\n      itemCount = this.props.itemCount;\n    }\n\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      currentOffset: this.state && this.state.offset || 0,\n      targetIndex: index\n    });\n  };\n\n  VirtualList.prototype.recomputeSizes = function (startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n\n    this.styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n\n  VirtualList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        estimatedItemSize = _a.estimatedItemSize,\n        height = _a.height,\n        _b = _a.overscanCount,\n        overscanCount = _b === void 0 ? 3 : _b,\n        renderItem = _a.renderItem,\n        itemCount = _a.itemCount,\n        itemSize = _a.itemSize,\n        onItemsRendered = _a.onItemsRendered,\n        onScroll = _a.onScroll,\n        _c = _a.scrollDirection,\n        scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n        scrollOffset = _a.scrollOffset,\n        scrollToIndex = _a.scrollToIndex,\n        scrollToAlignment = _a.scrollToAlignment,\n        stickyIndices = _a.stickyIndices,\n        style = _a.style,\n        width = _a.width,\n        props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n\n    var offset = this.state.offset;\n\n    var _d = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[sizeProp[scrollDirection]] || 0,\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _d.start,\n        stop = _d.stop;\n\n    var items = [];\n\n    var wrapperStyle = __assign({}, STYLE_WRAPPER, style, {\n      height: height,\n      width: width\n    });\n\n    var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n\n    if (stickyIndices != null && stickyIndices.length !== 0) {\n      stickyIndices.forEach(function (index) {\n        return items.push(renderItem({\n          index: index,\n          style: _this.getStyle(index, true)\n        }));\n      });\n\n      if (scrollDirection === DIRECTION.HORIZONTAL) {\n        innerStyle.display = 'flex';\n      }\n    }\n\n    if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n      for (var index = start; index <= stop; index++) {\n        if (stickyIndices != null && stickyIndices.includes(index)) {\n          continue;\n        }\n\n        items.push(renderItem({\n          index: index,\n          style: this.getStyle(index, false)\n        }));\n      }\n\n      if (typeof onItemsRendered === 'function') {\n        onItemsRendered({\n          startIndex: start,\n          stopIndex: stop\n        });\n      }\n    }\n\n    return createElement(\"div\", __assign({\n      ref: this.getRef\n    }, props, {\n      style: wrapperStyle\n    }), createElement(\"div\", {\n      style: innerStyle\n    }, items));\n\n    var _e;\n  };\n\n  VirtualList.prototype.getNodeOffset = function () {\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    return this.rootNode[scrollProp[scrollDirection]];\n  };\n\n  VirtualList.prototype.getEstimatedItemSize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n  };\n\n  VirtualList.prototype.getSize = function (index, itemSize) {\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n\n  VirtualList.prototype.getStyle = function (index, sticky) {\n    var style = this.styleCache[index];\n\n    if (style) {\n      return style;\n    }\n\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n\n    var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        size = _b.size,\n        offset = _b.offset;\n\n    return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n\n    var _c, _d;\n  };\n\n  VirtualList.defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION.VERTICAL,\n    width: '100%'\n  };\n  VirtualList.propTypes = {\n    estimatedItemSize: number,\n    height: oneOfType([number, string]).isRequired,\n    itemCount: number.isRequired,\n    itemSize: oneOfType([number, array, func]).isRequired,\n    onScroll: func,\n    onItemsRendered: func,\n    overscanCount: number,\n    renderItem: func.isRequired,\n    scrollOffset: number,\n    scrollToIndex: number,\n    scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n    scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n    stickyIndices: arrayOf(number),\n    style: object,\n    width: oneOfType([number, string])\n  };\n  return VirtualList;\n}(PureComponent);\n\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;","map":{"version":3,"names":["PureComponent","createElement","array","arrayOf","func","number","object","oneOf","oneOfType","string","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__rest","e","indexOf","getOwnPropertySymbols","ALIGNMENT","DIRECTION","SCROLL_CHANGE_REASON","scrollProp","_a","VERTICAL","HORIZONTAL","sizeProp","_b","positionProp","_c","marginProp","_d","oppositeMarginProp","_e","SizeAndPositionManager","itemCount","itemSizeGetter","estimatedItemSize","itemSizeAndPositionData","lastMeasuredIndex","updateConfig","getLastMeasuredIndex","getSizeAndPositionForIndex","index","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","offset","size","isNaN","getTotalSize","getUpdatedOffsetForIndex","align","START","containerSize","currentOffset","targetIndex","datum","maxOffset","minOffset","idealOffset","END","CENTER","Math","max","min","totalSize","getVisibleRange","overscanCount","start","findNearestItem","stop","resetItem","binarySearch","high","low","exponentialSearch","middle","floor","interval","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","top","left","STYLE_STICKY_ITEM","VirtualList","_super","_this","itemSize","getSize","sizeAndPositionManager","props","getEstimatedItemSize","state","scrollOffset","scrollToIndex","getOffsetForIndex","scrollChangeReason","REQUESTED","styleCache","getRef","node","rootNode","handleScroll","event","onScroll","getNodeOffset","target","setState","OBSERVED","componentDidMount","addEventListener","passive","scrollTo","UNSAFE_componentWillReceiveProps","nextProps","scrollToAlignment","scrollPropsHaveChanged","itemPropsHaveChanged","recomputeSizes","componentDidUpdate","_","prevState","componentWillUnmount","removeEventListener","value","scrollDirection","startIndex","render","height","renderItem","onItemsRendered","stickyIndices","style","items","wrapperStyle","innerStyle","forEach","push","getStyle","display","includes","stopIndex","ref","isArray","sticky","zIndex","defaultProps","propTypes","isRequired","AUTO","ScrollDirection"],"sources":["C:/Users/anish/auth-final/node_modules/@segment/react-tiny-virtual-list/build/react-tiny-virtual-list.es.js"],"sourcesContent":["import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\n\nvar ALIGNMENT;\n(function (ALIGNMENT) {\n    ALIGNMENT[\"AUTO\"] = \"auto\";\n    ALIGNMENT[\"START\"] = \"start\";\n    ALIGNMENT[\"CENTER\"] = \"center\";\n    ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\nvar DIRECTION;\n(function (DIRECTION) {\n    DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n    DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\nvar SCROLL_CHANGE_REASON;\n(function (SCROLL_CHANGE_REASON) {\n    SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n    SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\n\n/* Forked from react-virtualized ðŸ’– */\nvar SizeAndPositionManager = /** @class */function () {\n    function SizeAndPositionManager(_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        this.itemSizeGetter = itemSizeGetter;\n        this.itemCount = itemCount;\n        this.estimatedItemSize = estimatedItemSize;\n        // Cache of size and position data for items, mapped by item index.\n        this.itemSizeAndPositionData = {};\n        // Measurements for items up to this index can be trusted; items afterward should be estimated.\n        this.lastMeasuredIndex = -1;\n    }\n    SizeAndPositionManager.prototype.updateConfig = function (_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        if (itemCount != null) {\n            this.itemCount = itemCount;\n        }\n        if (estimatedItemSize != null) {\n            this.estimatedItemSize = estimatedItemSize;\n        }\n        if (itemSizeGetter != null) {\n            this.itemSizeGetter = itemSizeGetter;\n        }\n    };\n    SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n        return this.lastMeasuredIndex;\n    };\n    /**\n     * This method returns the size and position for the item at the specified index.\n     * It just-in-time calculates (or used cached values) for items leading up to the index.\n     */\n    SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n        if (index < 0 || index >= this.itemCount) {\n            throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n        }\n        if (index > this.lastMeasuredIndex) {\n            var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n            var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n            for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n                var size = this.itemSizeGetter(i);\n                if (size == null || isNaN(size)) {\n                    throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n                }\n                this.itemSizeAndPositionData[i] = {\n                    offset: offset,\n                    size: size\n                };\n                offset += size;\n            }\n            this.lastMeasuredIndex = index;\n        }\n        return this.itemSizeAndPositionData[index];\n    };\n    SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n        return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };\n    };\n    /**\n     * Total size of all items being measured.\n     * This value will be completedly estimated initially.\n     * As items as measured the estimate will be updated.\n     */\n    SizeAndPositionManager.prototype.getTotalSize = function () {\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n    };\n    /**\n     * Determines a new offset that ensures a certain item is visible, given the alignment.\n     *\n     * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @return Offset to use to ensure the specified item is visible\n     */\n    SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n        var _b = _a.align,\n            align = _b === void 0 ? ALIGNMENT.START : _b,\n            containerSize = _a.containerSize,\n            currentOffset = _a.currentOffset,\n            targetIndex = _a.targetIndex;\n        if (containerSize <= 0) {\n            return 0;\n        }\n        var datum = this.getSizeAndPositionForIndex(targetIndex);\n        var maxOffset = datum.offset;\n        var minOffset = maxOffset - containerSize + datum.size;\n        var idealOffset;\n        switch (align) {\n            case ALIGNMENT.END:\n                idealOffset = minOffset;\n                break;\n            case ALIGNMENT.CENTER:\n                idealOffset = maxOffset - (containerSize - datum.size) / 2;\n                break;\n            case ALIGNMENT.START:\n                idealOffset = maxOffset;\n                break;\n            default:\n                idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        }\n        var totalSize = this.getTotalSize();\n        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    };\n    SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n        var containerSize = _a.containerSize,\n            offset = _a.offset,\n            overscanCount = _a.overscanCount;\n        var totalSize = this.getTotalSize();\n        if (totalSize === 0) {\n            return {};\n        }\n        var maxOffset = offset + containerSize;\n        var start = this.findNearestItem(offset);\n        if (typeof start === 'undefined') {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        var datum = this.getSizeAndPositionForIndex(start);\n        offset = datum.offset + datum.size;\n        var stop = start;\n        while (offset < maxOffset && stop < this.itemCount - 1) {\n            stop++;\n            offset += this.getSizeAndPositionForIndex(stop).size;\n        }\n        if (overscanCount) {\n            start = Math.max(0, start - overscanCount);\n            stop = Math.min(stop + overscanCount, this.itemCount - 1);\n        }\n        return {\n            start: start,\n            stop: stop\n        };\n    };\n    /**\n     * Clear all cached values for items after the specified index.\n     * This method should be called for any item that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n     */\n    SizeAndPositionManager.prototype.resetItem = function (index) {\n        this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n    };\n    /**\n     * Searches for the item (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest item index will be returned.\n     * This allows partially visible items (with offsets just before/above the fold) to be visible.\n     */\n    SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n        if (isNaN(offset)) {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        // Our search algorithms find the nearest match at or below the specified offset.\n        // So make sure the offset is at least 0 or no match will be found.\n        offset = Math.max(0, offset);\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n        if (lastMeasuredSizeAndPosition.offset >= offset) {\n            // If we've already measured items within this range just use a binary search as it's faster.\n            return this.binarySearch({\n                high: lastMeasuredIndex,\n                low: 0,\n                offset: offset\n            });\n        } else {\n            // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n            // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n            // The overall complexity for this approach is O(log n).\n            return this.exponentialSearch({\n                index: lastMeasuredIndex,\n                offset: offset\n            });\n        }\n    };\n    SizeAndPositionManager.prototype.binarySearch = function (_a) {\n        var low = _a.low,\n            high = _a.high,\n            offset = _a.offset;\n        var middle = 0;\n        var currentOffset = 0;\n        while (low <= high) {\n            middle = low + Math.floor((high - low) / 2);\n            currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n            if (currentOffset === offset) {\n                return middle;\n            } else if (currentOffset < offset) {\n                low = middle + 1;\n            } else if (currentOffset > offset) {\n                high = middle - 1;\n            }\n        }\n        if (low > 0) {\n            return low - 1;\n        }\n        return 0;\n    };\n    SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n        var index = _a.index,\n            offset = _a.offset;\n        var interval = 1;\n        while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n            index += interval;\n            interval *= 2;\n        }\n        return this.binarySearch({\n            high: Math.min(index, this.itemCount - 1),\n            low: Math.floor(index / 2),\n            offset: offset\n        });\n    };\n    return SizeAndPositionManager;\n}();\n\nvar STYLE_WRAPPER = {\n    overflow: 'auto',\n    willChange: 'transform',\n    WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n    position: 'relative',\n    width: '100%',\n    minHeight: '100%'\n};\nvar STYLE_ITEM = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%'\n};\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, { position: 'sticky' });\nvar VirtualList = /** @class */function (_super) {\n    __extends(VirtualList, _super);\n    function VirtualList() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.itemSizeGetter = function (itemSize) {\n            return function (index) {\n                return _this.getSize(index, itemSize);\n            };\n        };\n        _this.sizeAndPositionManager = new SizeAndPositionManager({\n            itemCount: _this.props.itemCount,\n            itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n            estimatedItemSize: _this.getEstimatedItemSize()\n        });\n        _this.state = {\n            offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n            scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n        };\n        _this.styleCache = {};\n        _this.getRef = function (node) {\n            _this.rootNode = node;\n        };\n        _this.handleScroll = function (event) {\n            var onScroll = _this.props.onScroll;\n            var offset = _this.getNodeOffset();\n            if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n                return;\n            }\n            _this.setState({\n                offset: offset,\n                scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n            });\n            if (typeof onScroll === 'function') {\n                onScroll(offset, event);\n            }\n        };\n        return _this;\n    }\n    VirtualList.prototype.componentDidMount = function () {\n        var _a = this.props,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex;\n        this.rootNode.addEventListener('scroll', this.handleScroll, {\n            passive: true\n        });\n        if (scrollOffset != null) {\n            this.scrollTo(scrollOffset);\n        } else if (scrollToIndex != null) {\n            this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n        }\n    };\n    VirtualList.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            scrollOffset = _a.scrollOffset,\n            scrollToAlignment = _a.scrollToAlignment,\n            scrollToIndex = _a.scrollToIndex;\n        var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n        var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n        if (nextProps.itemSize !== itemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n            });\n        }\n        if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemCount: nextProps.itemCount,\n                estimatedItemSize: this.getEstimatedItemSize(nextProps)\n            });\n        }\n        if (itemPropsHaveChanged) {\n            this.recomputeSizes();\n        }\n        if (nextProps.scrollOffset !== scrollOffset) {\n            this.setState({\n                offset: nextProps.scrollOffset || 0,\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n            this.setState({\n                offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        }\n    };\n    VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n        var _a = this.state,\n            offset = _a.offset,\n            scrollChangeReason = _a.scrollChangeReason;\n        if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n            this.scrollTo(offset);\n        }\n    };\n    VirtualList.prototype.componentWillUnmount = function () {\n        this.rootNode.removeEventListener('scroll', this.handleScroll);\n    };\n    VirtualList.prototype.scrollTo = function (value) {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        this.rootNode[scrollProp[scrollDirection]] = value;\n    };\n    VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n        if (scrollToAlignment === void 0) {\n            scrollToAlignment = this.props.scrollToAlignment;\n        }\n        if (itemCount === void 0) {\n            itemCount = this.props.itemCount;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        if (index < 0 || index >= itemCount) {\n            index = 0;\n        }\n        return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n            align: scrollToAlignment,\n            containerSize: this.props[sizeProp[scrollDirection]],\n            currentOffset: this.state && this.state.offset || 0,\n            targetIndex: index\n        });\n    };\n    VirtualList.prototype.recomputeSizes = function (startIndex) {\n        if (startIndex === void 0) {\n            startIndex = 0;\n        }\n        this.styleCache = {};\n        this.sizeAndPositionManager.resetItem(startIndex);\n    };\n    VirtualList.prototype.render = function () {\n        var _this = this;\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            height = _a.height,\n            _b = _a.overscanCount,\n            overscanCount = _b === void 0 ? 3 : _b,\n            renderItem = _a.renderItem,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            onItemsRendered = _a.onItemsRendered,\n            onScroll = _a.onScroll,\n            _c = _a.scrollDirection,\n            scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex,\n            scrollToAlignment = _a.scrollToAlignment,\n            stickyIndices = _a.stickyIndices,\n            style = _a.style,\n            width = _a.width,\n            props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n        var offset = this.state.offset;\n        var _d = this.sizeAndPositionManager.getVisibleRange({\n            containerSize: this.props[sizeProp[scrollDirection]] || 0,\n            offset: offset,\n            overscanCount: overscanCount\n        }),\n            start = _d.start,\n            stop = _d.stop;\n        var items = [];\n        var wrapperStyle = __assign({}, STYLE_WRAPPER, style, { height: height, width: width });\n        var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n        if (stickyIndices != null && stickyIndices.length !== 0) {\n            stickyIndices.forEach(function (index) {\n                return items.push(renderItem({\n                    index: index,\n                    style: _this.getStyle(index, true)\n                }));\n            });\n            if (scrollDirection === DIRECTION.HORIZONTAL) {\n                innerStyle.display = 'flex';\n            }\n        }\n        if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n            for (var index = start; index <= stop; index++) {\n                if (stickyIndices != null && stickyIndices.includes(index)) {\n                    continue;\n                }\n                items.push(renderItem({\n                    index: index,\n                    style: this.getStyle(index, false)\n                }));\n            }\n            if (typeof onItemsRendered === 'function') {\n                onItemsRendered({\n                    startIndex: start,\n                    stopIndex: stop\n                });\n            }\n        }\n        return createElement(\"div\", __assign({ ref: this.getRef }, props, { style: wrapperStyle }), createElement(\"div\", { style: innerStyle }, items));\n        var _e;\n    };\n    VirtualList.prototype.getNodeOffset = function () {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        return this.rootNode[scrollProp[scrollDirection]];\n    };\n    VirtualList.prototype.getEstimatedItemSize = function (props) {\n        if (props === void 0) {\n            props = this.props;\n        }\n        return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n    };\n    VirtualList.prototype.getSize = function (index, itemSize) {\n        if (typeof itemSize === 'function') {\n            return itemSize(index);\n        }\n        return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n    };\n    VirtualList.prototype.getStyle = function (index, sticky) {\n        var style = this.styleCache[index];\n        if (style) {\n            return style;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n            size = _b.size,\n            offset = _b.offset;\n        return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n        var _c, _d;\n    };\n    VirtualList.defaultProps = {\n        overscanCount: 3,\n        scrollDirection: DIRECTION.VERTICAL,\n        width: '100%'\n    };\n    VirtualList.propTypes = {\n        estimatedItemSize: number,\n        height: oneOfType([number, string]).isRequired,\n        itemCount: number.isRequired,\n        itemSize: oneOfType([number, array, func]).isRequired,\n        onScroll: func,\n        onItemsRendered: func,\n        overscanCount: number,\n        renderItem: func.isRequired,\n        scrollOffset: number,\n        scrollToIndex: number,\n        scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n        scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n        stickyIndices: arrayOf(number),\n        style: object,\n        width: oneOfType([number, string])\n    };\n    return VirtualList;\n}(PureComponent);\n\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}